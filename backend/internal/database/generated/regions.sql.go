// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: regions.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const getAllRegions = `-- name: GetAllRegions :many
SELECT
  jis_code,
  name,
  name_kana,
  region_type,
  parent_jis_code,
  created_at,
  updated_at
FROM
  regions
ORDER BY
  jis_code
`

// GetAllRegions
//
//	SELECT
//	  jis_code,
//	  name,
//	  name_kana,
//	  region_type,
//	  parent_jis_code,
//	  created_at,
//	  updated_at
//	FROM
//	  regions
//	ORDER BY
//	  jis_code
func (q *Queries) GetAllRegions(ctx context.Context) ([]Region, error) {
	rows, err := q.db.QueryContext(ctx, getAllRegions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Region{}
	for rows.Next() {
		var i Region
		if err := rows.Scan(
			&i.JisCode,
			&i.Name,
			&i.NameKana,
			&i.RegionType,
			&i.ParentJisCode,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMunicipalitiesByPrefecture = `-- name: GetMunicipalitiesByPrefecture :many
SELECT
  jis_code,
  name,
  name_kana,
  region_type,
  parent_jis_code,
  created_at,
  updated_at
FROM
  regions
WHERE
  region_type = 'municipality'
  AND parent_jis_code = $1
ORDER BY
  jis_code
`

// GetMunicipalitiesByPrefecture
//
//	SELECT
//	  jis_code,
//	  name,
//	  name_kana,
//	  region_type,
//	  parent_jis_code,
//	  created_at,
//	  updated_at
//	FROM
//	  regions
//	WHERE
//	  region_type = 'municipality'
//	  AND parent_jis_code = $1
//	ORDER BY
//	  jis_code
func (q *Queries) GetMunicipalitiesByPrefecture(ctx context.Context, parentJisCode sql.NullString) ([]Region, error) {
	rows, err := q.db.QueryContext(ctx, getMunicipalitiesByPrefecture, parentJisCode)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Region{}
	for rows.Next() {
		var i Region
		if err := rows.Scan(
			&i.JisCode,
			&i.Name,
			&i.NameKana,
			&i.RegionType,
			&i.ParentJisCode,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPrefectures = `-- name: GetPrefectures :many
SELECT
  jis_code,
  name,
  name_kana,
  region_type,
  parent_jis_code,
  created_at,
  updated_at
FROM
  regions
WHERE
  region_type = 'prefecture'
ORDER BY
  jis_code
`

// GetPrefectures
//
//	SELECT
//	  jis_code,
//	  name,
//	  name_kana,
//	  region_type,
//	  parent_jis_code,
//	  created_at,
//	  updated_at
//	FROM
//	  regions
//	WHERE
//	  region_type = 'prefecture'
//	ORDER BY
//	  jis_code
func (q *Queries) GetPrefectures(ctx context.Context) ([]Region, error) {
	rows, err := q.db.QueryContext(ctx, getPrefectures)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Region{}
	for rows.Next() {
		var i Region
		if err := rows.Scan(
			&i.JisCode,
			&i.Name,
			&i.NameKana,
			&i.RegionType,
			&i.ParentJisCode,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRegionByCode = `-- name: GetRegionByCode :one
SELECT
  jis_code,
  name,
  name_kana,
  region_type,
  parent_jis_code,
  created_at,
  updated_at
FROM
  regions
WHERE
  jis_code = $1
`

// GetRegionByCode
//
//	SELECT
//	  jis_code,
//	  name,
//	  name_kana,
//	  region_type,
//	  parent_jis_code,
//	  created_at,
//	  updated_at
//	FROM
//	  regions
//	WHERE
//	  jis_code = $1
func (q *Queries) GetRegionByCode(ctx context.Context, jisCode string) (Region, error) {
	row := q.db.QueryRowContext(ctx, getRegionByCode, jisCode)
	var i Region
	err := row.Scan(
		&i.JisCode,
		&i.Name,
		&i.NameKana,
		&i.RegionType,
		&i.ParentJisCode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRegionHierarchy = `-- name: GetRegionHierarchy :many
SELECT
  r.jis_code,
  r.name,
  r.name_kana,
  r.region_type,
  r.parent_jis_code,
  p.name AS parent_name,
  r.created_at,
  r.updated_at
FROM
  regions r
  LEFT JOIN regions p ON r.parent_jis_code = p.jis_code
ORDER BY
  r.region_type,
  r.jis_code
`

type GetRegionHierarchyRow struct {
	JisCode       string         `json:"jis_code"`
	Name          string         `json:"name"`
	NameKana      string         `json:"name_kana"`
	RegionType    string         `json:"region_type"`
	ParentJisCode sql.NullString `json:"parent_jis_code"`
	ParentName    sql.NullString `json:"parent_name"`
	CreatedAt     time.Time      `json:"created_at"`
	UpdatedAt     time.Time      `json:"updated_at"`
}

// GetRegionHierarchy
//
//	SELECT
//	  r.jis_code,
//	  r.name,
//	  r.name_kana,
//	  r.region_type,
//	  r.parent_jis_code,
//	  p.name AS parent_name,
//	  r.created_at,
//	  r.updated_at
//	FROM
//	  regions r
//	  LEFT JOIN regions p ON r.parent_jis_code = p.jis_code
//	ORDER BY
//	  r.region_type,
//	  r.jis_code
func (q *Queries) GetRegionHierarchy(ctx context.Context) ([]GetRegionHierarchyRow, error) {
	rows, err := q.db.QueryContext(ctx, getRegionHierarchy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRegionHierarchyRow{}
	for rows.Next() {
		var i GetRegionHierarchyRow
		if err := rows.Scan(
			&i.JisCode,
			&i.Name,
			&i.NameKana,
			&i.RegionType,
			&i.ParentJisCode,
			&i.ParentName,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
