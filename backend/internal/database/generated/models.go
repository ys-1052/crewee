// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0

package db

import (
	"database/sql"
	"database/sql/driver"
	"fmt"
	"time"

	"github.com/google/uuid"
)

type ApplicationStatus string

const (
	ApplicationStatusPENDING    ApplicationStatus = "PENDING"
	ApplicationStatusACCEPTED   ApplicationStatus = "ACCEPTED"
	ApplicationStatusDECLINED   ApplicationStatus = "DECLINED"
	ApplicationStatusCANCELED   ApplicationStatus = "CANCELED"
	ApplicationStatusWAITLISTED ApplicationStatus = "WAITLISTED"
)

func (e *ApplicationStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ApplicationStatus(s)
	case string:
		*e = ApplicationStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for ApplicationStatus: %T", src)
	}
	return nil
}

type NullApplicationStatus struct {
	ApplicationStatus ApplicationStatus `json:"application_status"`
	Valid             bool              `json:"valid"` // Valid is true if ApplicationStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullApplicationStatus) Scan(value interface{}) error {
	if value == nil {
		ns.ApplicationStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ApplicationStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullApplicationStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ApplicationStatus), nil
}

type EventStatus string

const (
	EventStatusOPEN     EventStatus = "OPEN"
	EventStatusCLOSED   EventStatus = "CLOSED"
	EventStatusCANCELED EventStatus = "CANCELED"
)

func (e *EventStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = EventStatus(s)
	case string:
		*e = EventStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for EventStatus: %T", src)
	}
	return nil
}

type NullEventStatus struct {
	EventStatus EventStatus `json:"event_status"`
	Valid       bool        `json:"valid"` // Valid is true if EventStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullEventStatus) Scan(value interface{}) error {
	if value == nil {
		ns.EventStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.EventStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullEventStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.EventStatus), nil
}

type EventVisibility string

const (
	EventVisibilityPUBLIC   EventVisibility = "PUBLIC"
	EventVisibilityUNLISTED EventVisibility = "UNLISTED"
)

func (e *EventVisibility) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = EventVisibility(s)
	case string:
		*e = EventVisibility(s)
	default:
		return fmt.Errorf("unsupported scan type for EventVisibility: %T", src)
	}
	return nil
}

type NullEventVisibility struct {
	EventVisibility EventVisibility `json:"event_visibility"`
	Valid           bool            `json:"valid"` // Valid is true if EventVisibility is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullEventVisibility) Scan(value interface{}) error {
	if value == nil {
		ns.EventVisibility, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.EventVisibility.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullEventVisibility) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.EventVisibility), nil
}

type RegionLevel string

const (
	RegionLevelPREFECTURE   RegionLevel = "PREFECTURE"
	RegionLevelMUNICIPALITY RegionLevel = "MUNICIPALITY"
)

func (e *RegionLevel) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = RegionLevel(s)
	case string:
		*e = RegionLevel(s)
	default:
		return fmt.Errorf("unsupported scan type for RegionLevel: %T", src)
	}
	return nil
}

type NullRegionLevel struct {
	RegionLevel RegionLevel `json:"region_level"`
	Valid       bool        `json:"valid"` // Valid is true if RegionLevel is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullRegionLevel) Scan(value interface{}) error {
	if value == nil {
		ns.RegionLevel, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.RegionLevel.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullRegionLevel) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.RegionLevel), nil
}

type SkillLevel string

const (
	SkillLevelBEGINNER     SkillLevel = "BEGINNER"
	SkillLevelINTERMEDIATE SkillLevel = "INTERMEDIATE"
	SkillLevelADVANCED     SkillLevel = "ADVANCED"
)

func (e *SkillLevel) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SkillLevel(s)
	case string:
		*e = SkillLevel(s)
	default:
		return fmt.Errorf("unsupported scan type for SkillLevel: %T", src)
	}
	return nil
}

type NullSkillLevel struct {
	SkillLevel SkillLevel `json:"skill_level"`
	Valid      bool       `json:"valid"` // Valid is true if SkillLevel is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSkillLevel) Scan(value interface{}) error {
	if value == nil {
		ns.SkillLevel, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SkillLevel.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSkillLevel) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SkillLevel), nil
}

type Application struct {
	ID              uuid.UUID         `json:"id"`
	EventID         uuid.UUID         `json:"event_id"`
	ApplicantUserID uuid.UUID         `json:"applicant_user_id"`
	Message         sql.NullString    `json:"message"`
	Status          ApplicationStatus `json:"status"`
	CreatedAt       time.Time         `json:"created_at"`
	UpdatedAt       time.Time         `json:"updated_at"`
}

type Event struct {
	ID          uuid.UUID       `json:"id"`
	TeamID      uuid.UUID       `json:"team_id"`
	CreatedBy   uuid.UUID       `json:"created_by"`
	SportID     uuid.UUID       `json:"sport_id"`
	RegionCode  string          `json:"region_code"`
	Title       string          `json:"title"`
	StartAt     time.Time       `json:"start_at"`
	DurationMin int32           `json:"duration_min"`
	Level       SkillLevel      `json:"level"`
	Capacity    int32           `json:"capacity"`
	Fee         sql.NullString  `json:"fee"`
	Note        sql.NullString  `json:"note"`
	Status      EventStatus     `json:"status"`
	Visibility  EventVisibility `json:"visibility"`
	CreatedAt   time.Time       `json:"created_at"`
	UpdatedAt   time.Time       `json:"updated_at"`
}

type EventComment struct {
	ID              uuid.UUID     `json:"id"`
	EventID         uuid.UUID     `json:"event_id"`
	AuthorUserID    uuid.UUID     `json:"author_user_id"`
	ParentCommentID uuid.NullUUID `json:"parent_comment_id"`
	Body            string        `json:"body"`
	IsPinned        bool          `json:"is_pinned"`
	CreatedAt       time.Time     `json:"created_at"`
	UpdatedAt       time.Time     `json:"updated_at"`
	DeletedAt       sql.NullTime  `json:"deleted_at"`
}

type Region struct {
	JisCode       string         `json:"jis_code"`
	Name          string         `json:"name"`
	NameKana      string         `json:"name_kana"`
	RegionType    string         `json:"region_type"`
	ParentJisCode sql.NullString `json:"parent_jis_code"`
	CreatedAt     time.Time      `json:"created_at"`
	UpdatedAt     time.Time      `json:"updated_at"`
}

type Sport struct {
	ID        uuid.UUID `json:"id"`
	Code      string    `json:"code"`
	Name      string    `json:"name"`
	IsActive  bool      `json:"is_active"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

type Team struct {
	ID          uuid.UUID `json:"id"`
	OwnerUserID uuid.UUID `json:"owner_user_id"`
	SportID     uuid.UUID `json:"sport_id"`
	Name        string    `json:"name"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
}

type TeamRegion struct {
	ID         uuid.UUID      `json:"id"`
	TeamID     uuid.UUID      `json:"team_id"`
	RegionCode string         `json:"region_code"`
	Note       sql.NullString `json:"note"`
	CreatedAt  time.Time      `json:"created_at"`
	UpdatedAt  time.Time      `json:"updated_at"`
}

type User struct {
	ID              uuid.UUID    `json:"id"`
	Email           string       `json:"email"`
	Name            string       `json:"name"`
	EmailVerifiedAt sql.NullTime `json:"email_verified_at"`
	HomeRegionCode  string       `json:"home_region_code"`
	CreatedAt       time.Time    `json:"created_at"`
	UpdatedAt       time.Time    `json:"updated_at"`
}
